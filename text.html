<!-- vim: sw=4 ts=4 expandtab smartindent ft=javascript
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebGL Demo</title>
    <style> document, body { margin: 0px; padding: 0px; overflow: hidden; } </style>
  </head>

  <body>
    <canvas id="inspectorGraphCanvas"></canvas>
    <script>

/* maps character to location in spritesheet */
const sdfs = {};
let buffer;
/* higher number = prettier text using more VRAM */
const SDF_FONT_SIZE = 48;

const updateSDF = (() => {

    const chars = ' abcdefghijklmnopqrstuvwxyzZABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()1234567890<,>./?;:\'"\\|{}[]';
    const fontCanvas = document.createElement('canvas');
    fontCanvas.width = fontCanvas.height = 512
    const ctx = fontCanvas.getContext('2d');

    const TinySDF = (() => {
        const INF = 1e20;

        class TinySDF {
            constructor({
                fontSize = 24,
                buffer = 3,
                radius = 8,
                cutoff = 0.25,
                fontFamily = 'sans-serif',
                fontWeight = 'normal',
                fontStyle = 'normal'
            } = {}) {
                this.buffer = buffer;
                this.cutoff = cutoff;
                this.radius = radius;

                // make the canvas size big enough to both have the specified buffer around the glyph
                // for "halo", and account for some glyphs possibly being larger than their font size
                const size = this.size = fontSize + buffer * 4;

                const canvas = this._createCanvas(size);
                const ctx = this.ctx = canvas.getContext('2d', {willReadFrequently: true});
                ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;

                ctx.textBaseline = 'alphabetic';
                ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment
                ctx.fillStyle = 'black';

                // temporary arrays for the distance transform
                this.gridOuter = new Float64Array(size * size);
                this.gridInner = new Float64Array(size * size);
                this.f = new Float64Array(size);
                this.z = new Float64Array(size + 1);
                this.v = new Uint16Array(size);
            }

            _createCanvas(size) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                return canvas;
            }

            draw(char) {
                const {
                    width: glyphAdvance,
                    actualBoundingBoxAscent,
                    actualBoundingBoxDescent,
                    actualBoundingBoxLeft,
                    actualBoundingBoxRight
                } = this.ctx.measureText(char);

                // The integer/pixel part of the top alignment is encoded in metrics.glyphTop
                // The remainder is implicitly encoded in the rasterization
                const glyphTop = Math.ceil(actualBoundingBoxAscent);
                const glyphLeft = 0;

                // If the glyph overflows the canvas size, it will be clipped at the bottom/right
                const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
                const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));

                const width = glyphWidth + 2 * this.buffer;
                const height = glyphHeight + 2 * this.buffer;

                const len = Math.max(width * height, 0);
                const data = new Uint8ClampedArray(len);
                const glyph = {data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance};
                if (glyphWidth === 0 || glyphHeight === 0) return glyph;

                const {ctx, buffer, gridInner, gridOuter} = this;
                ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
                ctx.fillText(char, buffer, buffer + glyphTop);
                const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);

                // Initialize grids outside the glyph range to alpha 0
                gridOuter.fill(INF, 0, len);
                gridInner.fill(0, 0, len);

                for (let y = 0; y < glyphHeight; y++) {
                    for (let x = 0; x < glyphWidth; x++) {
                        const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value
                        if (a === 0) continue; // empty pixels

                        const j = (y + buffer) * width + x + buffer;

                        if (a === 1) { // fully drawn pixels
                            gridOuter[j] = 0;
                            gridInner[j] = INF;

                        } else { // aliased pixels
                            const d = 0.5 - a;
                            gridOuter[j] = d > 0 ? d * d : 0;
                            gridInner[j] = d < 0 ? d * d : 0;
                        }
                    }
                }

                edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
                edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);

                for (let i = 0; i < len; i++) {
                    const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
                    data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
                }

                return glyph;
            }
        }

        // 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf
        function edt(data, x0, y0, width, height, gridSize, f, v, z) {
            for (let x = x0; x < x0 + width; x++) edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);
            for (let y = y0; y < y0 + height; y++) edt1d(data, y * gridSize + x0, 1, width, f, v, z);
        }

        // 1D squared distance transform
        function edt1d(grid, offset, stride, length, f, v, z) {
            v[0] = 0;
            z[0] = -INF;
            z[1] = INF;
            f[0] = grid[offset];

            for (let q = 1, k = 0, s = 0; q < length; q++) {
                f[q] = grid[offset + q * stride];
                const q2 = q * q;
                do {
                    const r = v[k];
                    s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
                } while (s <= z[k] && --k > -1);

                k++;
                v[k] = q;
                z[k] = s;
                z[k + 1] = INF;
            }

            for (let q = 0, k = 0; q < length; q++) {
                while (z[k + 1] < q) k++;
                const r = v[k];
                const qr = q - r;
                grid[offset + q * stride] = f[r] + qr * qr;
            }
        }

        return TinySDF
    })()

    return function updateSDF() {
        // Convert alpha-only to RGBA so we can use `putImageData` for building the composite bitmap
        function makeRGBAImageData(alphaChannel, width, height) {
            const imageData = ctx.createImageData(width, height);
            for (let i = 0; i < alphaChannel.length; i++) {
                imageData.data[4 * i + 0] = alphaChannel[i];
                imageData.data[4 * i + 1] = alphaChannel[i];
                imageData.data[4 * i + 2] = alphaChannel[i];
                imageData.data[4 * i + 3] = 255;
            }
            return imageData;
        }

        const charWidths = Array.from({ length: chars.length }, _ => 0);

        ctx.clearRect(0, 0, fontCanvas.width, fontCanvas.height);
        const fontSize = +SDF_FONT_SIZE;
        const fontWeight = +SDF_FONT_SIZE;
        const fontStyle = 'normal';
        buffer = Math.ceil(fontSize / 8);
        const radius = Math.ceil(fontSize / 3);
        const sdf = new TinySDF({fontSize, buffer, radius, fontWeight, fontStyle});
        const size = fontSize + buffer * 2;

        const now = performance.now();
        let i = 0;
        for (let y = 0; y + size <= fontCanvas.height && i < chars.length; y += size) {
            for (let x = 0; x + size <= fontCanvas.width && i < chars.length; x += size) {
                const glyph = sdf.draw(chars[i]);
                const {data, width, height} = glyph;
                delete glyph.data;
                sdfs[chars[i]] = { x, y, glyph };
                ctx.putImageData(makeRGBAImageData(data, width, height), x, y);
                i++;
            }
        }
        console.log(`${i} characters (${fontSize}px, font-weight: ${fontWeight} with ${buffer}px buffer) rendered in ${Math.round(performance.now() - now)}ms.`)

        return ctx.getImageData(0, 0, fontCanvas.width, fontCanvas.height)
    }
})()

function mat4_create() {
      let out = new Float32Array(16);
      out[0] = 1;
      out[5] = 1;
      out[10] = 1;
      out[15] = 1;
      return out;
}
function mat4_ortho(out, left, right, bottom, top, near, far) {
    let lr = 1 / (left - right);
    let bt = 1 / (bottom - top);
    let nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}

const canvas2 = document.getElementById('inspectorGraphCanvas');
canvas2.width = window.innerWidth;
canvas2.height = window.innerHeight;

if (window.devicePixelRatio > 1) {
    canvas2.style.width = `${canvas2.width}px`;
    canvas2.style.height = `${canvas2.height}px`;
    canvas2.width *= 2;
    canvas2.height *= 2;
}

const gl = canvas2.getContext('webgl', {antialias: false});
if (!gl) { alert('Failed to initialize WebGL'); }

let shader;
/* compile shaders */
{
    const vertexSource = `
        attribute vec2 a_pos;
        attribute vec2 a_texcoord;

        uniform mat4 u_matrix;
        uniform vec2 u_texsize;

        varying vec2 v_texcoord;

        void main() {
            gl_Position = u_matrix * vec4(a_pos.xy, 0, 1);
            v_texcoord = a_texcoord / u_texsize;
        }`;

    const fragmentSource = `
        precision mediump float;

        uniform sampler2D u_texture;
        uniform vec4 u_color;
        uniform float u_buffer;
        uniform float u_gamma;

        varying vec2 v_texcoord;

        void main() {
            float dist = texture2D(u_texture, v_texcoord).r;
            float alpha = smoothstep(u_buffer - u_gamma, u_buffer + u_gamma, dist);
            gl_FragColor = vec4(u_color.rgb, alpha * u_color.a);
        }`;

    function createProgram(gl, vertexSource, fragmentSource) {
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        const program = gl.createProgram();

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error(gl.getProgramInfoLog(program));
        }

        const wrapper = {program};

        const numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (let i = 0; i < numAttributes; i++) {
            const attribute = gl.getActiveAttrib(program, i);
            wrapper[attribute.name] = gl.getAttribLocation(program, attribute.name);
        }
        const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < numUniforms; i++) {
            const uniform = gl.getActiveUniform(program, i);
            wrapper[uniform.name] = gl.getUniformLocation(program, uniform.name);
        }

        return wrapper;
    }


    shader = createProgram(gl, vertexSource, fragmentSource);
}

gl.useProgram(shader.program);
gl.enableVertexAttribArray(shader.a_pos);
gl.enableVertexAttribArray(shader.a_texcoord);

const pMatrix = mat4_ortho(mat4_create(), 0, gl.canvas.width, gl.canvas.height, 0, 0, -1);

const texture = gl.createTexture();

const vertexBuffer = gl.createBuffer();
const textureBuffer = gl.createBuffer();

/* upload new SDF to texture */
{
    const sdfImage = updateSDF();
    // sdfs[' '].width = sdfs['w'].width;
    const sdfBytes = new Uint8Array(sdfImage.data)

    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfImage.width, sdfImage.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, sdfBytes);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.uniform2f(shader.u_texsize, sdfImage.width, sdfImage.height);
}

(function frame() {
    requestAnimationFrame(frame);

    const str = 'newspaper quality';

    function drawText(size) {
        const vertexElements = [];
        const textureElements = [];

        const fontsize = SDF_FONT_SIZE;
        const buf = fontsize / 8;
        const width = fontsize + buf * 2; // glyph width
        const height = fontsize + buf * 2; // glyph height
        const bx = 0; // bearing x

        const scale = size / fontsize;
        const lineWidth = str.length * fontsize * scale;

        const pen = {x: canvas2.width / 2 - lineWidth / 2, y: canvas2.height / 2};
        for (let i = 0; i < str.length; i++) {
            const posX = sdfs[str[i]].x; // pos in sprite x
            const posY = sdfs[str[i]].y; // pos in sprite y
            const advance = sdfs[str[i]].glyph.glyphAdvance;
            const by = sdfs[str[i]].glyph.glyphTop - (fontsize / 2 + buf); // bearing y

            vertexElements.push(
                pen.x + ((bx - buf) * scale), pen.y - by * scale,
                pen.x + ((bx - buf + width) * scale), pen.y - by * scale,
                pen.x + ((bx - buf) * scale), pen.y + (height - by) * scale,

                pen.x + ((bx - buf + width) * scale), pen.y - by * scale,
                pen.x + ((bx - buf) * scale), pen.y + (height - by) * scale,
                pen.x + ((bx - buf + width) * scale), pen.y + (height - by) * scale
            );

            textureElements.push(
                posX, posY,
                posX + width, posY,
                posX, posY + height,
                posX + width, posY,
                posX, posY + height,
                posX + width, posY + height
            );

            pen.x = pen.x + advance * scale;
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexElements), gl.STATIC_DRAW);
        vertexBuffer.numItems = vertexElements.length / 2;

        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureElements), gl.STATIC_DRAW);
        textureBuffer.numItems = textureElements.length / 2;
    }

    /* set up premultiplied alpha */
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
    gl.enable(gl.BLEND);

    /* clear all */
    gl.clearColor(0.93, 0.9, 0.89, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    {
        const scale = 128;
        const gamma = 2;

        drawText(scale);

        gl.uniformMatrix4fv(shader.u_matrix, false, pMatrix);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(shader.u_texture, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(shader.a_pos, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
        gl.vertexAttribPointer(shader.a_texcoord, 2, gl.FLOAT, false, 0, 0);

        gl.uniform4fv(shader.u_color, [1, 1, 1, 1]);
        gl.uniform1f(shader.u_buffer, buffer);
        gl.drawArrays(gl.TRIANGLES, 0, vertexBuffer.numItems);

        gl.uniform4fv(shader.u_color, [0, 0, 0, 1]);
        gl.uniform1f(shader.u_buffer, 0.75);
        gl.uniform1f(shader.u_gamma, gamma * 1.4142 / scale);
        gl.drawArrays(gl.TRIANGLES, 0, vertexBuffer.numItems);
    }

})()


    </script>
  </body>
</html>
